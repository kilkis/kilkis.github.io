{"meta":{"title":"Shawn's Blog","subtitle":null,"description":null,"author":"Shawn","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Unity游戏底层-资源打包","slug":"resourcemanager_1","date":"2018-05-05T16:00:00.000Z","updated":"2018-05-07T14:58:13.801Z","comments":true,"path":"2018/05/06/resourcemanager_1/","link":"","permalink":"http://yoursite.com/2018/05/06/resourcemanager_1/","excerpt":"","text":"Unity资源管理-资源打包 一.需要完成哪些功能呢？&emsp;&emsp;1.自动分平台打包&emsp;&emsp;2.通过md5来确认是否需要打包文件&emsp;&emsp;3.允许单独打包不需要依赖的资源文件 二.通用代码&emsp;&emsp;我们需要引用几个必要的命名空间1234567using UnityEngine;using UnityEditor;using UnityEditor.SceneManagement;using System.Collections;using System.Collections.Generic;using System.IO;using System.Xml; &emsp;&emsp;然后根据平台设定一下不同的目录以及BuildTarget,区分目录的好处是多平台导出的时候，可以马上知道是什么平台的资源12345678910111213#if UNITY_IPHONE public static string m_Platform = \"ios/\"; public static BuildTarget m_target = BuildTarget.iOS;#elif UNITY_ANDROID public static string m_Platform = \"android/\"; public static BuildTarget m_target = BuildTarget.Android;#elif UNITY_STANDALONE_WIN public static string m_Platform = \"windows/\"; public static BuildTarget m_target = BuildTarget.StandaloneWindows64;#elif UNITY_STANDALONE_OSX public static string m_Platform = \"osx/\"; public static BuildTarget m_target = BuildTarget.StandaloneOSXUniversal;#endif &emsp;&emsp;自己按照导出内容，写一个函数，加上[MenuItem(“xxxx/xxxx”)]的修饰，其中xxxx替换为想要的菜单结构,类似以下结构12[MenuItem(\"Tools/Assetbundle/ExportJsonMap\")]public static void AutoExportJsonMap()&#123;&#125; 三.打包资源&emsp;&emsp;Unity的资源打包主要方式是设置所有需要打包的资源文件的assetBundleNames，然后调用同一的命令打包&emsp;&emsp;拿UI的资源做例子123456789101112131415161718192021222324252627public static void ExportAtlas(BuildTarget target, string path)&#123; //我们需要创建放置打包资源的目录，防止目录缺失导致报错 Directory.CreateDirectory(Application.dataPath + \"/StreamingAssets/atlas/\");//创建文件目录 Directory.CreateDirectory(Application.dataPath + \"/StreamingAssets/atlas/\" + path); DirectoryInfo rootDirInfo = new DirectoryInfo(Application.dataPath + \"/Atlas\"); foreach (DirectoryInfo dirInfo in rootDirInfo.GetDirectories()) &#123; //遍历atlas目录下所有需要打包的atlas资源，将他们按对应的atlas分类打包 AssetBundleBuild build = new AssetBundleBuild(); build.assetBundleName = \"Atlas/\" + path + dirInfo.Name + \".unity3d\"; List&lt;string&gt; files = new List&lt;string&gt;(); List&lt;Sprite&gt; assets = new List&lt;Sprite&gt;(); foreach (FileInfo pngFile in dirInfo.GetFiles(\"*.*\", SearchOption.AllDirectories)) &#123; if (pngFile.FullName.EndsWith(\".png\") || pngFile.FullName.EndsWith(\".jpg\")) &#123; string allPath = pngFile.FullName.Replace('\\\\', '/'); allPath = allPath.Replace(Application.dataPath, \"\"); allPath = \"Assets\" + allPath; files.Add(allPath); &#125; &#125; build.assetNames = files.ToArray(); maps.Add(build); &#125;&#125; &emsp;&emsp;资源最后打包的时候就靠一句话1BuildPipeline.BuildAssetBundles(AssetBundlesOutputPath, maps.ToArray(), BuildAssetBundleOptions.DeterministicAssetBundle | BuildAssetBundleOptions.ChunkBasedCompression, target); &emsp;&emsp;其中AssetBundlesOutputPath就是最终要输出的主目录，maps里存放了所有的AssetBundleBuild信息，压缩使用的方式是我们测试下来比较适合手游的方式，target就是平台","categories":[{"name":"开源项目","slug":"开源项目","permalink":"http://yoursite.com/categories/开源项目/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"},{"name":"资源管理","slug":"资源管理","permalink":"http://yoursite.com/tags/资源管理/"}]},{"title":"Unity游戏底层框架普及","slug":"intro","date":"2018-04-29T16:00:00.000Z","updated":"2018-05-05T12:57:52.544Z","comments":true,"path":"2018/04/30/intro/","link":"","permalink":"http://yoursite.com/2018/04/30/intro/","excerpt":"","text":"Unity游戏制作底层框架-因 一.为什么要做这样一个框架？&emsp;&emsp;因为我比较懒，不太愿意做重复的工作。。。&emsp;&emsp;然后一个好的框架，可以节省两个方面的消耗：一个是团队内程序上手的时间，以及制作相应功能消耗的时间，另一个则是可以节省后期游戏优化所消耗的时间和需要的团队的能力。因为在框架的机制内制作，会将游戏性能的底线拉高，性能再差也会比没有框架的游戏结构要好。 二.为什么要分享出来？&emsp;&emsp;这个框架在公司内已经有四款Unity项目使用了，两款线上，一款测试，一款在研，为什么我想要分享出来？&emsp;&emsp;最近两天我在看吴军的《见识》，突然觉得，总应该在能力范围内为这个社会，为愿意做游戏的同学们做点什么，让新入行的或者想要提升自己实力的兄弟姐妹们快速的达到一定的水准，也可以让使用Unity的创业团队，尤其不是有成熟的框架和项目经历的团队，更快速的更小风险的往前快速前进，努力在这个红海中活下来，把时间和精力用在做好游戏上，而不是其他上面。 三.这套框架里会有什么？&emsp;&emsp;首先，会有一个最底层的资源管理的机制，包含了打包，加载，以及项目内特殊需求的处理方案，其次，是UI的结构化设计与管理，可以大幅度减少UI制作难度和提高管理效率，另外，还有项目的自动化设计，Avatar相关的处理，王者荣耀级别的Shader与光影处理。","categories":[{"name":"开源项目","slug":"开源项目","permalink":"http://yoursite.com/categories/开源项目/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"},{"name":"介绍","slug":"介绍","permalink":"http://yoursite.com/tags/介绍/"}]}]}