{"meta":{"title":"Shawn's Blog","subtitle":null,"description":null,"author":"Shawn","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Unity Atlas格式自动化处理脚本","slug":"atlas","date":"2018-05-17T16:00:00.000Z","updated":"2018-05-18T13:22:41.174Z","comments":true,"path":"2018/05/18/atlas/","link":"","permalink":"http://yoursite.com/2018/05/18/atlas/","excerpt":"","text":"Unity Atlas格式自动化处理脚本 一.为什么要写这个脚本？&emsp;&emsp;在制作游戏的过程中，策划和美术同学会在项目里上传各类图片资源，比如角色的贴图，UI的贴图，通常意义上哪怕程序同学事先写了资源的定义文档，通常他们也很难100%的完全做到，一旦有文件没有改成必要的格式和配置，在未来跑游戏的时候，就可能造成性能上的，表现上的各种问题，所以，最好的解决方法，不是教他们怎么操作，而是自动帮他们做好！ 二.解决方案&emsp;&emsp;1.写一个脚本&emsp;&emsp;首先，我们在项目的Editor目录下建一个脚本，因为这个功能工作在图片进入项目的时刻，所以属于编辑器模式下,需要使用命名空间UnityEditor。12using UnityEngine;using UnityEditior; &emsp;&emsp;然后，想要在图片进入Editor的时候处理，就需要继承AssetPostprocessor类，这样就会有个OnPreprocessTexture()的接口可以继承123456public class TextureImportSetting : AssetPostprocessor &#123;&#123; void OnPreprocessTexture() &#123; &#125;&#125; &emsp;&emsp;在这个函数内，我们可以对图片的信息进行处理，使用this.assetPath来区分图片的目录，以达到设定不同属性的目的,比如这里我们来处理UI的贴图格式1234if( this.assetPath.Contains(\"Atlas\"))&#123; TextureImporter importer = (TextureImporter)assetImporter;&#125; &emsp;&emsp;UI的贴图通常需要设置成Sprite格式，mipmap是不需要的，默认的SpriteImportMode设为Single即可，有需要则按需在制作过程中程序手动修改123importer.textureType = TextureImporterType.Sprite; // 设置为Sprite类型importer.mipmapEnabled = false; // 禁用mipmapimporter.spriteImportMode = SpriteImportMode.Single; &emsp;&emsp;重点！敲黑板！总所周知，Unity的Ugui使用的Atlas机制，atlas打包是需要设定packingTag的，在这里，我们之前设计项目目录的好处就来了，这里可以直接设定atlas贴图的packingTag，这样unity就会自动将他们按照目录生成在一张贴图上12string[] tmp = this.assetPath.Split('/');importer.spritePackingTag = tmp[tmp.Length - 2]; &emsp;&emsp;然后，我们可以根据平台进行平台定制化的设定，这样在切换平台后，设定就不需要修改了123456789101112131415TextureImporterPlatformSettings textureSettings = new TextureImporterPlatformSettings();//允许覆盖设置textureSettings.overridden = true;//安卓平台的设置textureSettings.name = \"Android\";//最大贴图大小只允许1024textureSettings.maxTextureSize = 1024;//贴图格式设置为ETC_RGB4textureSettings.format = TextureImporterFormat.ETC_RGB4;//这顶压缩品质textureSettings.compressionQuality = 50;//允许自动将alpha通道分离textureSettings.allowsAlphaSplitting = true;//将平台设置配置进去importer.SetPlatformTextureSettings(textureSettings); &emsp;&emsp;最后，有个很好用的函数OnPostprocessAllAssets，他会在所有资源被导入、删除、移动完成之后调用，可以在这个函数里用来进行一些资源命名判定，比如大小写之类的，这样可以在资源变化的时候就确保命名的正确性，避免未来因为名称的问题而出现资源加载问题！","categories":[{"name":"开源项目","slug":"开源项目","permalink":"http://yoursite.com/categories/开源项目/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"},{"name":"Atlas","slug":"Atlas","permalink":"http://yoursite.com/tags/Atlas/"}]},{"title":"Unity游戏项目目录设计","slug":"unitydir","date":"2018-05-10T16:00:00.000Z","updated":"2018-05-11T12:35:29.574Z","comments":true,"path":"2018/05/11/unitydir/","link":"","permalink":"http://yoursite.com/2018/05/11/unitydir/","excerpt":"","text":"Unity游戏项目目录设计 一.为什么要设计目录结构？&emsp;&emsp;因为做一个游戏是需要一个团队的人多方合作的，如果每个人都按照自己的意愿来进行目录安排，那整个项目就会乱七八糟，游戏资源也会放的很散乱，所以我们需要对资源目录进行设计 二.如何设计&emsp;&emsp;首先，我们定义一个概念，我们以Application.dataPath为资源的根目录，下面的目录都在这个目录下&emsp;&emsp;1.我们需要一个非UI美术资源的目录，比如3D模型，贴图，材质球等，都放在该目录下123456//基础资源目录\\Art //动作目录，用于分离打包动作\\Art\\AnimatorController //Prefab的目录，打包时直接遍历其中的prefab进行打包\\Art\\Prefabs &emsp;&emsp;2.UI的2D图片，同一放在Atlas目录下，导入脚本设计会在之后的博客1234//Atlas的目录\\Atlas //用于区分不同的UI界面使用的贴图，并且会根据目录以及我们对贴图的导入设定，为导出资源提前分好目录\\Atlas\\atlas_xxxxxx &emsp;&emsp;3.音效文件，通常就建个单独的目录存放1\\Audio &emsp;&emsp;4.换装角色，也就是Avatar资源，通常也单独放置一个目录123456//Avatar的目录\\Avatar //Avatar的prefab，用于最终导出\\Avatar\\prefabs //比如anim，controller，texutre，因为Avatar是一个通过代码来整合的换装机制，所以基本所有资源都是可以拆的\\Avatar\\xxxxxx &emsp;&emsp;5.Unity的编辑器脚本，只能放在Editor目录下1\\Editor &emsp;&emsp;6.字体文件目录，我们需要准备一个目录单独存放字体，当然，字体有一些很棒的处理方式，之后博客也会提到1\\Fonts &emsp;&emsp;7.游戏场景目录，一个游戏的场景其实是有设计目的的，并不是需要一个就多一个这样，所以我们需要建一个目录统一管理下1\\Scenes &emsp;&emsp;8.Shader目录，将所以需要使用的shader，统一放在一个目录下，方便管理1\\Shader &emsp;&emsp;9.资源打包目录，也是必须的目录1\\StreamingAssets &emsp;&emsp;10.UI的目录，存放程序或者策划制作的UI的prefab123\\UI\\UI\\Prefabs\\UI\\Anim &emsp;&emsp;11.最后，就是脚本目录啦1\\Scripts","categories":[{"name":"开源项目","slug":"开源项目","permalink":"http://yoursite.com/categories/开源项目/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"},{"name":"资源管理","slug":"资源管理","permalink":"http://yoursite.com/tags/资源管理/"}]},{"title":"Unity游戏底层-资源打包","slug":"resourcemanager_1","date":"2018-05-05T16:00:00.000Z","updated":"2018-05-07T14:58:13.801Z","comments":true,"path":"2018/05/06/resourcemanager_1/","link":"","permalink":"http://yoursite.com/2018/05/06/resourcemanager_1/","excerpt":"","text":"Unity资源管理-资源打包 一.需要完成哪些功能呢？&emsp;&emsp;1.自动分平台打包&emsp;&emsp;2.通过md5来确认是否需要打包文件&emsp;&emsp;3.允许单独打包不需要依赖的资源文件 二.通用代码&emsp;&emsp;我们需要引用几个必要的命名空间1234567using UnityEngine;using UnityEditor;using UnityEditor.SceneManagement;using System.Collections;using System.Collections.Generic;using System.IO;using System.Xml; &emsp;&emsp;然后根据平台设定一下不同的目录以及BuildTarget,区分目录的好处是多平台导出的时候，可以马上知道是什么平台的资源12345678910111213#if UNITY_IPHONE public static string m_Platform = \"ios/\"; public static BuildTarget m_target = BuildTarget.iOS;#elif UNITY_ANDROID public static string m_Platform = \"android/\"; public static BuildTarget m_target = BuildTarget.Android;#elif UNITY_STANDALONE_WIN public static string m_Platform = \"windows/\"; public static BuildTarget m_target = BuildTarget.StandaloneWindows64;#elif UNITY_STANDALONE_OSX public static string m_Platform = \"osx/\"; public static BuildTarget m_target = BuildTarget.StandaloneOSXUniversal;#endif &emsp;&emsp;自己按照导出内容，写一个函数，加上[MenuItem(“xxxx/xxxx”)]的修饰，其中xxxx替换为想要的菜单结构,类似以下结构12[MenuItem(\"Tools/Assetbundle/ExportJsonMap\")]public static void AutoExportJsonMap()&#123;&#125; 三.打包资源&emsp;&emsp;Unity的资源打包主要方式是设置所有需要打包的资源文件的assetBundleNames，然后调用同一的命令打包&emsp;&emsp;拿UI的资源做例子123456789101112131415161718192021222324252627public static void ExportAtlas(BuildTarget target, string path)&#123; //我们需要创建放置打包资源的目录，防止目录缺失导致报错 Directory.CreateDirectory(Application.dataPath + \"/StreamingAssets/atlas/\");//创建文件目录 Directory.CreateDirectory(Application.dataPath + \"/StreamingAssets/atlas/\" + path); DirectoryInfo rootDirInfo = new DirectoryInfo(Application.dataPath + \"/Atlas\"); foreach (DirectoryInfo dirInfo in rootDirInfo.GetDirectories()) &#123; //遍历atlas目录下所有需要打包的atlas资源，将他们按对应的atlas分类打包 AssetBundleBuild build = new AssetBundleBuild(); build.assetBundleName = \"Atlas/\" + path + dirInfo.Name + \".unity3d\"; List&lt;string&gt; files = new List&lt;string&gt;(); List&lt;Sprite&gt; assets = new List&lt;Sprite&gt;(); foreach (FileInfo pngFile in dirInfo.GetFiles(\"*.*\", SearchOption.AllDirectories)) &#123; if (pngFile.FullName.EndsWith(\".png\") || pngFile.FullName.EndsWith(\".jpg\")) &#123; string allPath = pngFile.FullName.Replace('\\\\', '/'); allPath = allPath.Replace(Application.dataPath, \"\"); allPath = \"Assets\" + allPath; files.Add(allPath); &#125; &#125; build.assetNames = files.ToArray(); maps.Add(build); &#125;&#125; &emsp;&emsp;资源最后打包的时候就靠一句话1BuildPipeline.BuildAssetBundles(AssetBundlesOutputPath, maps.ToArray(), BuildAssetBundleOptions.DeterministicAssetBundle | BuildAssetBundleOptions.ChunkBasedCompression, target); &emsp;&emsp;其中AssetBundlesOutputPath就是最终要输出的主目录，maps里存放了所有的AssetBundleBuild信息，压缩使用的方式是我们测试下来比较适合手游的方式，target就是平台","categories":[{"name":"开源项目","slug":"开源项目","permalink":"http://yoursite.com/categories/开源项目/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"},{"name":"资源管理","slug":"资源管理","permalink":"http://yoursite.com/tags/资源管理/"}]},{"title":"Unity游戏底层框架普及","slug":"intro","date":"2018-04-29T16:00:00.000Z","updated":"2018-05-05T12:57:52.544Z","comments":true,"path":"2018/04/30/intro/","link":"","permalink":"http://yoursite.com/2018/04/30/intro/","excerpt":"","text":"Unity游戏制作底层框架-因 一.为什么要做这样一个框架？&emsp;&emsp;因为我比较懒，不太愿意做重复的工作。。。&emsp;&emsp;然后一个好的框架，可以节省两个方面的消耗：一个是团队内程序上手的时间，以及制作相应功能消耗的时间，另一个则是可以节省后期游戏优化所消耗的时间和需要的团队的能力。因为在框架的机制内制作，会将游戏性能的底线拉高，性能再差也会比没有框架的游戏结构要好。 二.为什么要分享出来？&emsp;&emsp;这个框架在公司内已经有四款Unity项目使用了，两款线上，一款测试，一款在研，为什么我想要分享出来？&emsp;&emsp;最近两天我在看吴军的《见识》，突然觉得，总应该在能力范围内为这个社会，为愿意做游戏的同学们做点什么，让新入行的或者想要提升自己实力的兄弟姐妹们快速的达到一定的水准，也可以让使用Unity的创业团队，尤其不是有成熟的框架和项目经历的团队，更快速的更小风险的往前快速前进，努力在这个红海中活下来，把时间和精力用在做好游戏上，而不是其他上面。 三.这套框架里会有什么？&emsp;&emsp;首先，会有一个最底层的资源管理的机制，包含了打包，加载，以及项目内特殊需求的处理方案，其次，是UI的结构化设计与管理，可以大幅度减少UI制作难度和提高管理效率，另外，还有项目的自动化设计，Avatar相关的处理，王者荣耀级别的Shader与光影处理。","categories":[{"name":"开源项目","slug":"开源项目","permalink":"http://yoursite.com/categories/开源项目/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"},{"name":"介绍","slug":"介绍","permalink":"http://yoursite.com/tags/介绍/"}]}]}